package template

var filesTemplate = `{{buildTags .Tags}}// Code generated by fileb0x from config file "{{.ConfigFile}}" DO NOT EDIT.

package {{.Pkg}}
{{$Compression := .Compression}}

import (
  "bytes"
  {{ if and $Compression.Compress }}{{if not $Compression.Keep}}"compress/gzip"{{end}}{{end}}
  "context"
  "io"
  "net/http"
  "os"
  "path"
  "golang.org/x/net/webdav"
)

var (
  _ = bytes.Buffer{}
  _ = io.Copy

  // CTX is a context for webdav vfs
  {{exported "CTX"}} = context.Background()

  // Inventory maps paths to slices
  {{exportedTitle "Inventory"}} = map[string][]byte{
    {{- range .Files }}
      "/{{ .Path }}": {{exportedTitle "File"}}{{ buildSafeVarName .Path }},
    {{- end -}}
  }
)

func NewHTTPFS() *HTTPFS {
   return &HTTPFS{
      FS: GetFS(),
   }
}

// HTTPFS implements http.FileSystem
type {{exported "HTTPFS"}} struct {
	// Prefix allows to limit the path of all requests. F.e. a prefix "css" would allow only calls to /css/*
	Prefix string
    FS webdav.FileSystem
}

{{range .Files}}
// {{exportedTitle "File"}}{{buildSafeVarName .Path}} is "{{.Path}}"
var {{exportedTitle "File"}}{{buildSafeVarName .Path}} = {{.Data}}
{{end}}

func GetFS() webdav.FileSystem {
  FS := webdav.NewMemFS()

  err := {{exported "CTX"}}.Err()
  if err != nil {
		panic(err)
	}

{{range $index, $dir := .DirList}}
  {{if and (ne $dir "./") (ne $dir "/") (ne $dir ".") (ne $dir "")}}
  err = FS.Mkdir({{exported "CTX"}}, "{{$dir}}", 0777)
  if err != nil && err != os.ErrExist {
    panic(err)
  }
  {{end}}
{{end}}

  var f webdav.File

  {{if $Compression.Compress}}
  {{if not $Compression.Keep}}
  var rb *bytes.Reader
  var r *gzip.Reader
  {{end}}
  {{end}}

  {{range .Files}}
  {{if $Compression.Compress}}
  {{if not $Compression.Keep}}
  rb = bytes.NewReader({{exportedTitle "File"}}{{buildSafeVarName .Path}})
  r, err = gzip.NewReader(rb)
  if err != nil {
    panic(err)
  }

  err = r.Close()
  if err != nil {
    panic(err)
  }
  {{end}}
  {{end}}

  f, err = FS.OpenFile({{exported "CTX"}}, "{{.Path}}", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
  if err != nil {
    panic(err)
  }

  {{if $Compression.Compress}}
  {{if not $Compression.Keep}}
  _, err = io.Copy(f, r)
  if err != nil {
    panic(err)
  }
  {{end}}
  {{else}}
  _, err = f.Write({{exportedTitle "File"}}{{buildSafeVarName .Path}})
  if err != nil {
    panic(err)
  }
  {{end}}

  err = f.Close()
  if err != nil {
    panic(err)
  }
  {{end}}

  return FS
}

// Open a file
func (hfs *{{exported "HTTPFS"}}) Open(path string) (http.File, error) {
  path = hfs.Prefix + path

  f, err := hfs.FS.OpenFile({{exported "CTX"}}, path, os.O_RDONLY, 0644)
  if err != nil {
    return nil, err
  }

  return f, nil
}

// ReadFile is adapTed from ioutil
func {{exportedTitle "ReadFile"}}(path string) ([]byte, error) {
  raw, pres := Inventory[path]
  if !pres {
     return nil, os.ErrNotExist
  }

  {{if $Compression.Compress}}

  rb := bytes.NewReader(raw)
  r, err := gzip.NewReader(rb)
  if err != nil {
    return nil, err
  }

  buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))
  _, err = buf.ReadFrom(r)
  return buf.Bytes(), err
  {{ else }}

  return raw, nil

  {{ end }}
}

// WalkDirs looks for files in the given dir and returns a list of files in it
// usage for all files in the b0x: WalkDirs("", false)
func {{exportedTitle "WalkDirs"}}(fs webdav.FileSystem, name string, includeDirsInList bool, files ...string) ([]string, error) {
	f, err := fs.OpenFile({{exported "CTX"}}, name, os.O_RDONLY, 0)
	if err != nil {
		return nil, err
	}

	fileInfos, err := f.Readdir(0)
	if err != nil {
    return nil, err
  }

  err = f.Close()
  if err != nil {
		return nil, err
	}

	for _, info := range fileInfos {
		filename := path.Join(name, info.Name())

		if includeDirsInList || !info.IsDir() {
			files = append(files, filename)
		}

		if info.IsDir() {
			files, err = {{exportedTitle "WalkDirs"}}(fs, filename, includeDirsInList, files...)
			if err != nil {
				return nil, err
			}
		}
	}

	return files, nil
}

`
